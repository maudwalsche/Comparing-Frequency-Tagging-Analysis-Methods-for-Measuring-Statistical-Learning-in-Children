# -*- coding: utf-8 -*-
"""
Project: TULIP

EEG preprocessing

Software versions
Python 3.11
MNE 1.5.0

@author: Liesa Ravijts (liesa.ravijts@ugent.be)
"""

#%% import packages
import os
import mne
import numpy as np
import pandas as pd

#mne.sys_info()

#%%
project_folder = 'C:/Users/lravijts/OneDrive - UGent/Documents/Projects/TULIP'
os.chdir(project_folder)

eeg_dir = 'C:/Users/lravijts/OneDrive - UGent/EEG DATA (no personal identifiers!)'
out_dir = os.path.join(project_folder, 'Data/EEG/processed')

plotting = True
save_output = True
overwrite = False

#%% experiment info
nwords = 4                            # number of pseudowords
nblocks = 4                           # number of exposure blocks
nblocks_rand = 1                      # number of random blocks
nblocks_stru = 3                      # number of structured blocks

nsyls_block = 288                     # number of syllables per block
nwords_block = nsyls_block // 3       # number of words per block
nreps_block = nwords_block // nwords  # number of repetitions

Fsyl = 1 / 0.390                      # syllable frequency (Hz) / 250 syl + 120 isi + 20 trig = 390 ms
Fword = 1 / (3 * 0.390)               # word frequency (Hz)

eeg_layout = 'easycap-M1'             # mne montage
Fs = 500                              # sampling frequency (Hz)

#%% read logbook
eeg_logbook = pd.read_excel(os.path.join(eeg_dir, 'EEG Logbook.xlsx'), header=3)
eeg_logbook = eeg_logbook[eeg_logbook.EEG_ON_TEAMS == 'X'].reset_index(drop=True)

nfiles = len(eeg_logbook)            # number of eeg files
nsubjs = len(set(eeg_logbook.SUB))   # number of unique identifiers

#%% make out_dir
if save_output and not os.path.exists(out_dir):
    os.mkdir(out_dir)
    os.mkdir(os.path.join(out_dir, 'bad_channels'))
    os.mkdir(os.path.join(out_dir, 'annotations'))


#%% selected file (first column EEG logbook)
idx = 1


#%%#########################
# Load the data
# --------------------------
subj_id = eeg_logbook.SUB[idx]
session = eeg_logbook.SESSION[idx]

print(f'/// SUBJECT {subj_id} - SESSION {session} ///')

#%%
fvhdr = f'TULIP_SUB{subj_id}_{session}_EEG.vhdr'
fpath = os.path.join(eeg_dir, fvhdr)

raw = mne.io.read_raw_brainvision(fpath, preload=True)
print(raw.info) # only 31 channels (active reference Cz not included)

#%% some checks
duration_min = len(raw) / raw.info['sfreq'] / 60
notes_eeg = eeg_logbook.EEG_NOTES[idx]
notes_session = eeg_logbook.OTHER_REMARKS_SESSION[idx]

print(f"{len(raw.info['ch_names'])} channels: {raw.info['ch_names']}")
print(f"Sampling frequency: {raw.info['sfreq']} Hz")
print(f'Recording duration: {round(duration_min, 2)} min')
print(f'Notes EEG: "{notes_eeg}"')
print(f'Notes session: "{notes_session}"')

#%%#########################
# Load and clean up events
# --------------------------
# trigger info in TULIP/Scripts/Experiment/EEG_triggers.docx

# BrainVision events are stored in annotations
events, event_mapping = mne.events_from_annotations(raw)

# SICR recorded?
sicr_recorded = True if 13 in event_mapping.values() else False

# events of interest
event_id = {'Start of EEG recording': 99999,
            'Start of structured block': 12,
            'End of block': 10,
            'Random - syllable onset': 4,
            'Structured - 1st syllable onset': 1,
            'Structured - 2nd syllable onset': 2,
            'Structured - 3rd syllable onset': 3,
            'ISI onset': 5}

if idx != 44:
    event_id['Start of random block'] = 11

if sicr_recorded:
    event_id['Start of SICR task'] = 13
    event_id['Target sequence'] = 21
    event_id['Foil sequence'] = 22
    event_id['End of sequence'] = 20

if plotting:
    mne.viz.plot_events(events, event_id=event_id, sfreq=Fs)

# check trigger values
value, count = np.unique(events[:,2], return_counts=True)
print(np.array((value, count)).T)
        
#%% drop the event annotations
raw.set_annotations(None)

#%% check syllable timing based on the triggers
timing = np.diff(events[:,0][np.isin(events[:,2], [1, 2, 3, 4])]) / Fs * 1000
timing = timing[timing < 1000]
        
print(f'min: {int(min(timing))} ms, max: {int(max(timing))} ms')

#%% take a look at the raw data (use + or - to zoom in or out, left and right arrows to move in time)
if plotting:
    raw.plot(n_channels=31, events=events, title=f'Subject {subj_id} ({session}): Raw data')

#%%#########################
# Extract exposure phase
# --------------------------
raw_exposure = raw.copy()
        
# 10 s buffer for filtering
if idx == 44:
    start = 0
else:
    start = events[:,0][events[:,2] == 11][0] / Fs - 10

stop = events[:,0][events[:,2] == 10][-1] / Fs + 10
if stop > len(raw) / Fs:
    stop = len(raw) / Fs - 2 * 1 / Fs
        
#%%
raw_exposure.crop(start, stop)

#%%
if plotting:
    raw_exposure.plot(n_channels=31, events=events, title=f'Subject {subj_id} ({session}): Raw data (exposure phase)')


#%%#########################
# Filtering
# --------------------------
# apply bandpass filter
raw_filt = raw_exposure.copy()
raw_filt.filter(l_freq=0.1, h_freq=30)

# if data contain a lot of slow drifts, it might be easier to use a higher l_freq cut-off during preprocessing
# then go back and set l_freq back to 0.1 Hz
#   first run: l_freq=0.5 (cut-off for preproc)
#   second run: l_freq=0.1 (cut-off for analysis)

#%%
if plotting:
    raw_filt.plot(n_channels=31, events=events, title=f'Subject {subj_id} ({session}): Filtered data')


#%%#########################
# Re-referencing
# --------------------------
raw_reref = raw_filt.copy()

# check data in TP9 and TP10 (electrodes located at the mastoids)
raw_reref.plot(order=[9, 20], events=events, title=f'Subject {subj_id} ({session}): Check signal in TP9 and TP10 (mastoids)')

#%%
ref_channels = ['TP9', 'TP10']
print(f'Channels used for re-referencing: {ref_channels}')
        
# add Cz (all zeros)
raw_reref = mne.add_reference_channels(raw_reref, ref_channels=['Cz'])
        
# re-reference to algebraic avg of the mastoids
raw_reref.set_eeg_reference(ref_channels=ref_channels)
raw_reref.drop_channels(['TP9', 'TP10'])


#%%#########################
# Interpolate bad channels
# --------------------------
raw_interp = raw_reref.copy()
fpath = os.path.join(out_dir, f'bad_channels/{fvhdr[:-5]}_bads.txt')

# click on channels to mark them bad (bad channels turn light gray), close the window to save
raw_interp.plot(n_channels=15, events=events, title=f'Subject {subj_id} ({session}): Mark channels for interpolation')

#%% write bads
if save_output and (not os.path.exists(fpath) or overwrite):
    f = open(fpath, 'w')
    f.write(str(raw_interp.info['bads']))
    f.close()

#%% apply montage
montage = mne.channels.make_standard_montage(eeg_layout)
raw_interp.set_montage(montage)

#%% channels marked for interpolation are plotted in red
raw_interp.plot(butterfly=True, color='#00000022', bad_color='r', events=events, title=f'Subject {subj_id} ({session}): Check channels marked as bad')
raw_interp.plot_sensors(show_names='all')

#%% interpolate channels
bads = raw_interp.info['bads']
if bads:
    print(f'Bad channels: {bads}')
    raw_interp.interpolate_bads()
            
    if plotting:
        raw_interp.plot(n_channels=30, events=events, title=f'Subject {subj_id} ({session}): Check data after interpolation')

#%%#########################
# Annotate bad segments
# --------------------------
raw_annot = raw_interp.copy()
fpath = os.path.join(out_dir, f'annotations/{fvhdr[:-5]}_annotations.txt')

#%% first run
# press 'a' and add 'BAD_' label with draggable edges
# make sure to stay within the edges of events (triplets!)
# close window to save
raw_annot.plot(n_channels=30, events=events, title=f'Subject {subj_id} ({session}): Annotate bad segments (= all electrodes noisy)')

annot = raw_annot.annotations

#%% save annotations
if save_output:
    annot.save(fpath, overwrite=overwrite)

# if this is the first run, go back to "Filtering" and change l_freq=0.5 to l_freq=0.1



#%% second run
raw_annot.set_annotations(annot) # set previously made annotations


#%%#########################
# Save preprocessed data
# --------------------------
raw_annot.info['description'] = f'custom_ref={ref_channels}, interpolated={bads}'
print(raw_annot.info)

#%%
if save_output:
    fpath = os.path.join(out_dir, f'{fvhdr[:-5]}_preproc_eeg.fif')
    raw_annot.save(fpath, overwrite=overwrite)

    fpath = os.path.join(out_dir, f'{fvhdr[:-5]}_events.npy')
    if overwrite or not os.path.exists(fpath):
        np.save(fpath, events)

